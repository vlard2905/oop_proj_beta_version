***

# The main criteria for evaluating the project are:
The degree of fulfillment of the task, the application of object-oriented mechanisms in the program (especially the appropriate use of **inheritance**, **polymorphism**(here([1](C:\prog\oop_proj\src\main\java\app\oop_proj\museums),[2](C:\prog\oop_proj\src\main\java\app\oop_proj\restourants),[3](C:\prog\oop_proj\src\main\java\app\oop_proj\water_entertainments)) you will find all the files which extends this [class](C:\prog\oop_proj\src\main\java\app\oop_proj\Entertainments.java)), **encapsulation** and **aggregation**), the organization of the code and the quality of the documentation.

***

## Other criteria include: (11 points need)

*  ### The use of *design patterns*: (3 points)
*Other than the Singleton design pattern - each implemented design pattern counts as meeting one additional criterion, but the implementation of all design patterns is assessed at the maximum level of meeting three additional criteria.*
* [Composite pattern.](C:/prog/oop_proj/src/main/java/app/oop_proj/museums/MuseumCenter.java)
* [Decorator pattern.](C:\prog\oop_proj\src\main\java\app\oop_proj\restourants\RestaurantDecorator.java)
* [Bridge pattern.](C:\prog\oop_proj\src\main\java\app\oop_proj\water_entertainments\WaterEntertainBridge.java)

---

*  ### Exception handling via *custom exceptions* (1 point)
*One custom exception is enough, but it must actually be thrown and handled.*
* [Too many veriables exception.](C:\prog\oop_proj\src\main\java\app\oop_proj\controllers\TooManyVeriables.java)
---

*  ### Provision of a graphical user interface (2 points)
* [Separated from the application logic.](C:\prog\oop_proj\src\main\resources\app\oop_proj)
* [With at least part of event handlers created manually.](C:\prog\oop_proj\src\main\java\app\oop_proj\controllers)

---

* ### Explicit use of *multithreading*
*Starting your own thread directly or via a higher-level API ( Task class , etc.).*

---

* ### Using *generosity* in custom classes 
*Implementing and using a custom generic class (as in the linked list example provided for lecture 5).*

---

* ### Explicit use of *RTTI*
*E.g. to determine the type of an object or create an object of the appropriate type (as in the game with giants and knights when determining the number of creatures).*

---
 
* ### Use of nested classes and interfaces 
*Only use in application logic counts, not in the GUI, while the interfaces must be their own (one option is in the example of inner classes for lecture 4).*

---

* ### Use of lambda expressions or references to methods (method references) 
*Only use in the application logic is counted, not in the GUI (one possibility is in the example of references to methods and lambda expressions for lecture 4).*

---

*  ### Use of implicit implementation of methods in interfaces (default method implementation)

---

*  ### Use of aspect-oriented programming (AspectJ)

---

*  ### [Use of serialization](C:\prog\oop_proj\src\main\java\app\oop_proj\controllers\Constructor.java) (1 point)

---
